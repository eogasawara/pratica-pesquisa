```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

# Fundamentos da Linguagem R

## Visão Geral
Este roteiro acompanha o conteúdo de `02-R-Basics.pdf` e foi organizado para leitura progressiva: tipos de dados, estruturas, manipulação tabular e integração com Python.  
Sugestão didática: execute os chunks em sequência e observe como os objetos são reaproveitados nas seções seguintes.  
Slides: 1-37.

## Como ler este roteiro
Siga a ordem dos blocos e, ao final de cada seção, revise:
1. quais objetos foram criados/alterados;
2. quais tipos de dados estão em uso;
3. como esse bloco prepara o próximo tópico.

## Instalação e Primeiros Objetos
Foco: instalar/carregar pacotes e consolidar operações básicas com variáveis numéricas e textuais.  
Slides: 5-8.

#### Instalacao e carregamento de pacotes R

Verificacao e instalacao de pacotes

```{r}
if(!require(daltoolbox)) { 
  install.packages("daltoolbox")
}
```

Carregamento de pacotes

```{r}
library(daltoolbox)
```

#### Definicao e avaliacao de variaveis

Definicao de variaveis

```{r}
weight <- 60
height = 1.75
subject <- "A"
healthy <- TRUE
```

Avaliacao de variaveis

```{r}
weight
```

#### Funcoes para verificacao de tipo

```{r}
is.numeric(weight) # variable 
is.double(weight)
is.integer(weight)
is.character(subject)
```

#### Funcoes para conversao de variaveis

```{r}
weight <- as.integer(weight)
is.integer(weight)
```

#### Formulas e formatacao de strings

Calculando o indice de massa corporal (IMC) a partir do peso e da altura

```{r}
#Body mass index (BMI)
bmi <- weight/height^2 
bmi 
```

Funcoes para manipulacao de strings

```{r}
message <- sprintf("%.1f", bmi)
print(message)
```

#### Vetores

definicao

```{r}
weight <- c(60, 72, 57, 90, 95, 72) 
height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
subject <- c("A", "B", "C", "D", "E", "F")
```

avaliacao

```{r}
weight
height
subject
```

#### Definindo o tamanho do vetor

vetor de tamanho 10

```{r}
vec <- rep(0, 10)
vec
```

tamanho do vetor

```{r}
length(weight)
```

#### Limites do vetor

da primeira ate a ultima posicao do vetor

```{r}
weight[1]
weight[length(weight)]
```

#### Iteracao: laco for

da primeira ate a ultima posicao de weight

```{r}
bmi <- 0
for (i in 1:length(weight)) {
  bmi[i] <- weight[i]/height[i]^2
}
```

avaliacao do vetor bmi

```{r}
bmi
```

#### Iteracao: laco while

executa enquanto i for menor ou igual ao tamanho de weight

```{r}
bmi <- 0
i <- 1
while (i <= length(weight)) {
  bmi[i] <- weight[i]/height[i]^2
  i <- i + 1
}
```

Resultado do cálculo com `while`:

```{r}
bmi
```

Nesta etapa, compare a versão com `for` e a versão com `while`: o resultado é igual, mas a clareza do código pode mudar conforme o problema.  
Slides: 10-11.

#### Removendo uma variavel

```{r}
rm(bmi)
exists("bmi")
```

#### Processando vetores de uma vez


```{r}
bmi <- weight/height^2 
bmi 
```

#### Criando funcoes

name <- function(parameters) { body }

```{r}
compute_bmi <- function(weight, height) {
  bmi <- weight/height^2 
  return(bmi)
}
```

chamando a funcao

```{r}

bmi <- compute_bmi(60, 1.75)
bmi
```

#### Funcao processando vetores

```{r}
bmi <- compute_bmi(weight, height)
bmi
```

#### Exemplo: funcao para calcular a media

(iterando em todos os elementos do vetor)

```{r}
average <- function(vec) {
    s <- 0
    n <- length(vec)
    for (x in vec) {
      s <- s + x  
    }
    return(s/n)
}
```

invocando a funcao

```{r}
avg_bmi <- average(bmi)
avg_bmi
```

#### Exemplo de funcao para calcular a media (versao melhorada)

manipulando vetores de uma vez

```{r}
average <- function(vec) {
    s <- sum(vec)
    n <- length(vec)
    return(s/n)
}
```

invocando a funcao

```{r}
avg_bmi <- average(bmi)
avg_bmi
```

#### Exemplo: funcao usando mean

As principais funcoes estatisticas estao disponiveis no R

```{r}
average <- function(vec) {
    return(mean(vec))
}
```

invocando a funcao

```{r}
avg_bmi <- average(bmi)
avg_bmi
```

#### Valores ausentes (NA)

Operacoes com NA resultam em NA.

```{r}
x <- c(10, NA, 13)
y <- average(x)
y
```

Tratando NA com na.rm=TRUE

```{r}
average <- function(vec) {
    return(mean(vec, na.rm=TRUE))
}
```

Teste rápido com vetor contendo NA:

```{r}
x <- c(10, NA, 13)
y <- average(x)
y
```

## Visualização e Tipos Categóricos
Foco: compreender quando usar gráficos básicos, fatores ordenados e discretização com `cut()`.  
Slides: 13-16.

#### Graficos basicos

definindo variaveis

```{r}
weight <- c(60, 72, 57, 90, 95, 72) 
height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
bmi <- weight/height^2 
```

graficos de dispersao

```{r fig.width=6, fig.height=4.5}
plot(height, weight)
```

#### A maioria das funcoes possui muitos parametros padrao

```{r fig.width=6, fig.height=4.5}
plot(height, weight, pch=2)
```

#### A janela de plotagem permanece ativa ate um novo grafico

```{r fig.width=6, fig.height=4.5}
plot(height, weight)
hh = c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90)
lines(hh, 22.5 * hh^2)
```

#### Fatores

Fatores sao usados para representar dados categoricos.

```{r}
pain <- c(0,3,2,2,1)
fpain <- factor(pain,levels=0:3, ordered=TRUE)
fpain
```

Os niveis fazem a correspondencia entre valores numericos e rotulos categoricos

```{r}
levels(fpain) <- c("none","mild","medium","severe")
fpain
```

#### Converter height em fator com niveis: pequeno, medio e alto

definindo elemento por elemento

```{r}
lev <- rep("", length(height))

for (i in 1:length(height)) {
  if (height[i] < 1.5)
    lev[i] <- "short"
  else if (height[i] < 1.9)
    lev[i] <- "medium"
  else 
    lev[i] <- "tall"
}

lev <- factor(lev, levels=c("small", "medium", "tall"), ordered=TRUE)
lev
```

#### Usando a funcao cut

```{r}
lev <- cut(height, breaks=c(0, 1.5, 1.9, .Machine$double.xmax), ordered=TRUE)
lev

levels(lev) <- c("short", "medium", "tall")
lev
```

## Estruturas de Dados em R
Foco: diferenças entre matriz, lista e data frame, e quando cada estrutura é mais adequada.  
Slides: 17-24.

#### Matrizes

Matrizes podem ser preenchidas a partir de vetores ou data frames. 

```{r}
x <- 1:9
x
```

Convertendo um vetor em matriz

```{r}
dim(x) <- c(3,3)
x
```

#### Multiplicacao escalar

```{r}
y <- 3*x
y
```

#### Matrizes manipulation

Convertendo um vetor em matriz por linha

```{r}
x <- matrix(1:9,nrow=3,byrow=TRUE)
x
```

transpondo uma matriz

```{r}
x <- t(x)
x
```

#### Listas

Listas sao usadas para trabalhar com "objetos"

```{r}
a <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
b <- c(3910,4220,3885,5160,5645,4680,5265,5975,6790,6900,7335)

mybag <- list(a, b, 0, "a")
mybag
```

#### Adicionando elementos em uma lista

```{r}
n <- length(mybag)
mybag[[n+1]] <- "b"
mybag
```

#### Fatiamento de lista

```{r}
slice <- mybag[1]
slice
is.list(slice)
```

#### Listas: member reference

Selecionando o primeiro elemento

```{r}
h <- mybag[[1]]
h
```

Um elemento pode ser avaliado. Neste caso, e um vetor.

```{r}
is.vector(h)
is.list(h)
```

#### Criando listas com atributos

Sao propriedades da lista

```{r}
mybag <- list(x=a, y=b, const=0, lit="a")
mybag
```

#### Adicionando, acessando e removendo elementos

```{r}
mybag$c <- mybag$x - mybag$y
mybag$const <- NULL
mybag$lit <- NULL
mybag
```

#### Data frames (quadros de dados)
Data frames (tabelas) oferecem suporte a dados estruturados. 

```{r}
a <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
b <- c(3910,4220,3885,5160,5645,4680,5265,5975,6790,6900,7335)
```

Montamos o `data.frame` base para as operações de coluna:

```{r}
data <- data.frame(A=a, B=b)
head(data)
```

#### Adicionando uma coluna em um data frame 

```{r}
data$c <- data$A + data$B
head(data)
```

#### Removendo uma coluna de um data frame 

```{r}
data$A <- NULL
head(data)
```

## Leitura, Escrita e Filtros
Foco: entrada/saída de dados e seleção de subconjuntos de forma reprodutível.  
Slides: 25-27.

#### Leitura de arquivo CSV
Ha diversas funcoes para ler formatos CSV, Excel e RData.

```{r}
wine = read.table(
    "http://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data", 
                  header = TRUE, sep = ",")
  colnames(wine) <- c('Type', 'Alcohol', 'Malic', 'Ash', 
                      'Alcalinity', 'Magnesium', 'Phenols', 
                      'Flavanoids', 'Nonflavanoids',
                      'Proanthocyanins', 'Color', 'Hue', 
                      'Dilution', 'Proline')
head(wine)
```

#### Salvando em formato binario

salvando um data frame


```{r}
save(wine, file="wine.RData")
```

removendo um data frame da memoria

```{r}
rm(wine)
```

carregando novamente

```{r}
load("wine.RData")
head(wine, 3)
```

#### Exportando data.frame para arquivo CSV

```{r}
write.table(wine, file="wine.csv", row.names=FALSE, quote = FALSE, sep = ",")
```

#### Filtrando vetores

```{r}
a <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)

# vetor logico
bool <- (a > 7000)
bool
```

Aplicamos o filtro lógico em duas formas equivalentes:

```{r}
# selecionando elementos nas posicoes verdadeiras
a[bool] 

a[a > 7000] 

```
#### Filtrando data frames

```{r}
a <- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
b <- c(3910,4220,3885,5160,5645,4680,5265,5975,6790,6900,7335)
data <- data.frame(a = a, b = b)
head(data[data$a > 7000,])
```

#### Filtrando data frames (linhas e colunas)

```{r}
head(data[data$a > 7000,c(1)])
```

#### Comparando desempenho entre matriz e data frame

```{r}
rheight <- rnorm(100000, 1.8, sd=0.2)
rweight <- rnorm(100000, 72, sd=15)
```

#### Calculando uma coluna de uma vez no data frame

```{r}
start_time <- Sys.time()

hw <- data.frame(height=rheight, weight=rweight)
hw$bmi <- hw$weight/hw$height^2

end_time <- Sys.time()
end_time - start_time

object.size(hw)
```

#### Calculando uma coluna no data frame celula a celula

```{r}
start_time <- Sys.time()
hw <- data.frame(height=rheight, weight=rweight)
for (i in 1:nrow(hw)) {
  hw$bmi[i] <- hw$weight[i]/hw$height[i]^2
}
end_time <- Sys.time()
end_time - start_time
```

#### Convertendo data frame para matriz, processando e retornando

```{r}
start_time <- Sys.time()
hw <- data.frame(height=rheight, weight=rweight)

hw <- as.matrix(hw)

hw <- cbind(hw, 0)
for (i in 1:nrow(hw)) {
  hw[i,3] <- hw[i,2]/hw[i,1]^2
}

hw <- as.data.frame(hw)

end_time <- Sys.time()
end_time - start_time
```

## Pipelines e Consultas em Tabelas
Foco: operações de consulta, agregação e junção para análise tabular.  
Slides: 28-34.

#### Pipelines
O operador |> cria um pipeline. 

O primeiro parametro da proxima funcao recebe os dados do pipeline. 

A biblioteca $dplyr$ contem funcoes que apoiam operacoes de algebra relacional.

```{r}
flight_data <- read.table(text = "Year Quarter Flights Delays
                     2016 1 11 6
                     2016 2 12 5
                     2016 3 13 3
                     2016 4 12 5
                     2017 1 10 4
                     2017 2 9 3
                     2017 3 11 4
                     2017 4 25 15
                     2018 1 14 3
                     2018 2 12 5
                     2018 3 13 3
                     2018 4 15 4",
                     header = TRUE,sep = "")  
```

#### Exibindo o data frame

```{r}
head(flight_data)
```

#### Consulta basica


```{r}
# dplyr nao e obrigatorio para os exemplos abaixo (base R)
```

Consulta base para selecionar voos com maior atraso:

```{r}
result <- flight_data[flight_data$Delays > 5, c("Year", "Quarter", "Flights")]
head(result)
```

#### Consulta agregada


```{r}
agg <- aggregate(
  Flights ~ Year,
  data = flight_data,
  FUN = function(x) c(mean = mean(x), sd = sd(x))
)
result <- data.frame(
  Year = agg$Year,
  mean = agg$Flights[, "mean"],
  sd = agg$Flights[, "sd"]
)
head(result)
```

#### Juncao de tabelas

Tabela de lojas

```{r}
stores <- data.frame(
  city = c("Rio de Janeiro", "Sao Paulo", "Paris", "New York", "Tokyo"),
  value = c(10, 12, 20, 25, 18))
head(stores)
```

Tabela de divisoes

```{r}
divisions <- data.frame(
  city = c("Rio de Janeiro", "Sao Paulo", "Paris", "New York", "Tokyo"),
  country = c("Brazil", "Brazil", "France", "US", "Japan"))
head(divisions)
```

#### Funcao merge

A funcao $merge$ pode ser usada para juntar data frames. Ela permite juncoes internas, esquerda, direita e externas. 

```{r}
stdiv <- merge(stores, divisions, by.x="city", by.y="city")
head(stdiv)
```
#### Agregando data frame mesclado

```{r}
count_tbl <- aggregate(value ~ country, data = stdiv, FUN = length)
sum_tbl <- aggregate(value ~ country, data = stdiv, FUN = sum)
result <- merge(count_tbl, sum_tbl, by = "country")
colnames(result) <- c("country", "count", "amount")
head(result)
```

#### Analise estatistica
Ha muitos testes estatisticos no R.
Um dos mais usados e o teste t. Ele verifica se a media observada difere de um valor teorico.

```{r}
weight <- c(60, 72, 57, 90, 95, 72) 
height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
bmi <- weight/height^2 
```

Executamos o teste t para comparar a média observada de IMC com o valor teórico `22.5`:

```{r}
t.test(bmi, mu=22.5)
```

## Integração R + Python
Foco: reaproveitar funções Python dentro de um fluxo R via `reticulate`.  
Slides: 36.

#### Integracao Python + R


Codigo Python em retic.py
```text
import pyreadr
import pandas

def add(x, y):
  return x + y

def read_rdata_mem(data):
  x = data["x"]
  print(x)
  y = data["y"]
  data["z"] = x + y
  return(data)
```

A biblioteca reticulate permite integracao direta com Python
```{r}
library(reticulate)
source_python('https://raw.githubusercontent.com/eogasawara/datamining/refs/heads/main/python/retic.py')
x <- add(5, 10)
x
```


#### Integracao de dados entre Python + R

```{r}
data <- data.frame(x = c(1:5), y=c(11:15))
dfm <- read_rdata_mem(data)
head(dfm)
```

## Referências
Slides: 37.

- Wickham, H., Cetinkaya-Rundel, M., & Grolemund, G. (2023). *R for Data Science* (2nd ed.). O'Reilly.
- Chambers, J. M. (2016). *Extending R*. Chapman and Hall/CRC.
- Ushey, K., Allaire, J., & Tang, Y. (2024). *reticulate: Interface to Python* (R package).


